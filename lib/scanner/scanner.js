/*▄────────────────────▄
  █                    █
  █  Загрузка модулей  █
  █                    █
  ▀────────────────────▀*/
const path = require('path');
const { Worker } = require('worker_threads');
const EventEmitter = require('core/event-emitter/default-options');
const utils = require('../utils');

/*▄────────────────────▄
  █                    █
  █  Создает приемник  █
  █                    █
  ▀────────────────────▀*/
module.exports = class extends EventEmitter.DefaultOptions {
/*┌────────────────────┐
  │ Опции по умолчанию │
  └────────────────────┘*/
    static defaultOptions = {
        iface:     'eth0', // Имя сетевого интерфейса
        delay:        100, // Задержка между пакетами   = 0.1 сек
        delayError: 60000, // Задержка после ошибки     =  60 сек
        timeout:   600000, // Время на получение пакета =  10 мин
        scan:       false, // Получение пакетов без задержки (false = выкл.)
    }
    
/*┌─────────────┐
  │ Конструктор │
  └─────────────┘*/
    constructor(options) {
    // Сохраняем опции с учетом значений по умолчанию
        super(options);
        
    // Запускаем приемник
        this.start();
    }
    
/*┌────────────────────┐
  │ Запускает приемник │
  └────────────────────┘*/
    start = () => {
    // Создаем новый воркер
        this.worker = new Worker(path.resolve(__dirname, 'worker.js'), {
        // Передаем опции в воркер
            workerData: {
                iface: this.options.iface, // Имя сетевого интерфейса
                delay: this.options.delay, // Задержка между пакетами
            }
        });
        
    // Создаем список обработчиков
        [
            'message', // Обработчик получения пакетов
            'error',   // Обработчик ошибок в воркере
            'exit',    // Обработчик аварийного завершения воркера
        ]
        
    // Инициализируем каждый обработчик
        .forEach(event => this.worker.on(event, (res) => this[event](res)));
        
    // Добавляем обработчик запуска
        this.worker.once('online', () => {
        // Обновляем состояние воркера
            this.online = true;
            
        // Обновляем перезапуск по таймауту
            this.updateTimeout();
            
        // Сообщаем о запуске
            this.emit('start');
        });
    }
    
/*┌────────────────────────┐
  │ Останавливает приемник │
  └────────────────────────┘*/
    stop = async () => {
    // Обновляем состояние воркера
        this.online = false;
        
    // Отменяем перезапуск по таймауту
        this.clearTimeout();
        
    // Проверяем текущий воркер
        if (this.worker) {
        // Удаляем все обработчики
            this.worker.removeAllListeners();
            
        // Останавливаем текущий воркер
            await this.worker.terminate();
            
        // Удаляем текущий воркер
            this.worker = null;
        }
        
    // Сообщаем об остановке
        this.emit('stop');
    }
    
/*┌────────────────────────┐
  │ Перезапускает приемник │
  └────────────────────────┘*/
    restart = async (reason) => {
    // Сообщаем о перезапуске
        this.emit('restart', reason);
        
    // Останавливаем приемник
        await this.stop();
        
    // Создаем задержку после ошибки
        if (reason == 'error') {
            await utils.sleep(this.options.delayError);
        }
        
    // Запускаем приемник
        this.start();
    }
    
/*┌─────────────────────────────────┐
  │ Отменяет перезапуск по таймауту │
  └─────────────────────────────────┘*/
    clearTimeout = () => {
        clearTimeout(this.timeoutId);
    }
    
/*┌──────────────────────────────────┐
  │ Обновляет перезапуск по таймауту │
  └──────────────────────────────────┘*/
    updateTimeout = () => {
    // Отменяем старый
        this.clearTimeout();
        
    // Добавляем новый
        this.timeoutId = setTimeout(() => {
        // Сообщаем о истечении времени получения пакета (приемник будет перезапущен)
            this.emit('timeout');
            
        // Перезапускаем приемник
            this.restart('timeout');
        },
        
        // Время на получение пакета
            this.options.timeout,
        );
    }
    
/*┌──────────────────────────────┐
  │ Обработчик получения пакетов │
  └──────────────────────────────┘*/
    message = (packet) => {
    // Обновляем перезапуск по таймауту
        this.updateTimeout();
        
    // Не удалось получить пакет
        if (packet.error) {
            return this.error(packet.error, packet.type);
        }
        
    // Создаем буфер из Uint8Array без копирования (используем ту же область памяти)
    // и пропускаем MAC-адрес (первые 6 байт пакета)
        const packetBuffer = Buffer.from(packet.buffer, packet.byteOffset + utils.MAC_SIZE);
        
    // Сообщаем о получении пакета
        this.emit('data', packetBuffer, packet, utils.macFilter);
        
    // Запускаем получение следующего пакета без задержки
        if (this.options.scan) {
            this.scan();
        }
    }
    
/*┌─────────────────────────────┐
  │ Обработчик ошибок в воркере │
  └─────────────────────────────┘*/
    error = (err, type = 'error') => this.emit('error', utils.formatError(type, err))
    
/*┌──────────────────────────────────────────┐
  │ Обработчик аварийного завершения воркера │
  └──────────────────────────────────────────┘*/
    exit = (code) => {
    // Сообщаем об аварийном завершении воркера
        this.emit('exit', code);
        
    // Перезапускаем приемник
        this.restart('error');
    }
    
/*┌────────────────────────────────────────────────────┐
  │ Запускает получение следующего пакета без задержки │
  └────────────────────────────────────────────────────┘*/
    scan = () => {
    // Запускаем получение следующего пакета без задержки
        if (this.online) {
            this.worker.postMessage([]);
        }
        
    // Сообщаем о запуске получения следующего пакета без задержки
        this.emit('scan');
    }
};
